class DisjointSet{
    int n;
    int size[];
    int parent[];
    public DisjointSet(int n){
        this.n=n;
        size = new int[n];
        parent = new int[n];

        for(int i=0;i<n;i++){
            size[i]=1;
            parent[i] = i;
        }
    }

    public int find(int x){
        if(x==parent[x]){
            return x;
        }
        int t = find(parent[x]);
        parent[x] = t;
        return t;
    }
    public boolean union(int x, int y){
        int ux = find(x);
        int uy = find(y);
        if(ux==uy){
            return false;
        }
        if(size[ux]>size[uy]){ 
            parent[uy] = ux;
            size[ux]+=size[uy];
        }else{
            parent[ux] = uy;
            size[uy]+=size[ux];
        }
        return true;
    }
}
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // only malware waale
        int f = initial[0];
        int n = graph.length;
        int iLen = initial.length;
        DisjointSet ds = new DisjointSet(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(graph[i][j]==1){
                   ds.union(i,j);
                }
            }
        }
        HashSet<Integer> hs = new HashSet();
        for(int i=0;i<iLen;i++){
            hs.add(initial[i]);
        }
        int save[] = new int[n];
        Arrays.sort(initial);
        int max = -1;
        int maxNode = -1;
        for(int i=0;i<iLen;i++){
            int node = initial[i];
            boolean canSave = true;
            int parent = ds.find(node);
            for(int j=0;j<n;j++){
                if(ds.find(j)==parent){
                    if(j != node && hs.contains(j)){
                        save[i] = 0;
                        canSave = false;
                        break;
                    }
                }
            }
            if(canSave){
                save[i] = ds.size[parent];
            }
            if(max<save[i]){
                max = save[i];
                maxNode = node;
            }
        }

        return maxNode==-1?f:maxNode;
    }
}